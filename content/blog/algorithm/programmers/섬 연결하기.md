---
title: "섬 연결하기"
date: "2021-02-25T11:18:46.169Z"
path: "/Algorithm/programmers/42861/"
category: "Algorithm"
ci: "Lv3"
cat: "PROGRAMMERS"
tags: ["PROGRAMMERS", "Python", "Lv3"]
description: "[Python | Programmers] 섬 연결하기"
---

<br />

<a href="https://programmers.co.kr/learn/courses/30/lessons/42861"><small>문제 바로가기</small></a>

###### 입출력

| n    | costs                                     | return |
| ---- | ----------------------------------------- | ------ |
| 4    | [[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]] | 4      |

<br />

##### <h5 style="color:#C587AE;">💻 풀이</h5>

```python
def solution(n, costs):
    answer = 1e9
    arr = [[0] * n for _ in range(n)]
    for cost in costs:
        arr[cost[0]][cost[1]] = cost[2]
        arr[cost[1]][cost[0]] = cost[2]

    def func(idx, S):
        nonlocal answer
        visit[idx] = 1
        if 0 not in visit:
            answer = min(answer, S)
            return
        for i in range(n):
            if visit[i]: continue
            if arr[idx][i]:
                visit[i] = 1
                func(i, S + arr[idx][i])
                visit[i] = 0

    for i in range(n):
        visit = [0] * n
        func(i, 0)

    return answer
```

<br />



<h5 style="color:#C587AE;">💻 다른사람의 풀이</h5>

1. 크루스칼 알고리즘

   ```python
   parent, rank = {}, {}
   
   # 모든 정점의 부모와 rank 초기화
   def make_set(v):
       parent[v] = v
       rank[v] = 0
       
       
   # 해당 정점의 최상위 정점 찾기
   def find(v):
       if parent[v] != v:
           parent[v] = find(parent[v])
       return parent[v]
   
   
   # 부모가 같지 않은 두 정점 연결하기
   def union(st, ed):
       start, end = find(st), find(ed)
       if start != end:
           if rank[start] > rank[end]:
               parent[end] = start
           else:
               parent[start] = end
               if rank[start] == rank[end]:
                   rank[end] += 1
                   
       
   def kruskal(n, costs):
       for v in range(n):
           make_set(v)
       mst = []
       edges = [(cost[2], cost[0], cost[1]) for cost in costs]
       edges.sort()
       for edge in edges:
           weight, st, ed = edge
           if find(st) != find(ed):
               union(st, ed)
               mst.append(edge)
       return mst
       
       
   def solution(n, costs):
       answer = 0
       tmp = kruskal(n, costs)
       for i in range(len(tmp)):
           answer += tmp[i][0]
       return answer
   ```

2. 프림 알고리즘

   ```python
   def solution(n, costs):
       answer = 0
       lst = {costs[0][0]}
       while len(lst) < n:
           idx = func(costs, lst)
           lst.update([costs[idx][0], costs[idx][1]])
           answer += costs[idx][2]
           costs.pop(idx)
       return answer
   
   def func(costs, lst):
       Min, idx = 1e9, 0
       for i in range(len(costs)):
           if costs[i][0] in lst and costs[i][1] in lst:
               continue
           if costs[i][0] in lst or costs[i][1] in lst:
               if costs[i][2] < Min:
                   Min = costs[i][2]
                   idx = i
       return idx
   ```

3. 크루스칼 알고리즘 변형

   ```python
   def solution(n, costs):
       answer = bridge = 0
       edges = sorted([(cost[2], cost[0], cost[1]) for cost in costs])
       parents = [i for i in range(n)]
       
       def find(v):
           if parents[v] != v:
               return find(parents[v])
           return parents[v]
       
       for weight, st, ed in edges:
           if find(st) != find(ed):
               parents[find(st)] = ed
               bridge += 1
               answer += weight
           if bridge == n - 1:
               break
               
       return answer
   ```

   

   



