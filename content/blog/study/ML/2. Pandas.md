---
title: "Pandas"
date: "2021-01-23T02:41:32.169Z"
path: "/Study/ml/2/"
category: "Study"
ci: "ML"
cat: "ML"
tags: ["ML", "Python", "Pandas"]
description: "ML - Pandas"
---



### Pandas

##### 특징

* Python의 엑셀 같은 존재
* 구조화된 데이터 처리 지원

<br />

##### 설치

* Conda

  ```sh
  conda install pandas
  ```

* pip

  ```sh
  pip install pandas
  ```

<br />

##### 사용

```python
import pandas as pd
# 보통 pd라는 별칭으로 호출
```

<br />

##### 함수

###### Series

```python
obj = pd.Series([1, 3, 5, 7, 9])
obj
# index data
# 0 1
# 1 3
# 2 5
# 3 7
# 4 9
```

```python
obj = pd.Series([1, 3, 5, 7, 9], ['a', 'b', 'c', 'd', 'e'])
obj
# index data
# a 1
# b 3
# c 5
# d 7
# e 9
```

```python
dic = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5}
obj = Series(dic)
# index data
# a 1
# b 3
# c 5
# d 7
# e 9
```

* index

  ```python
  dic = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5}
  obj = Series(dic)
  obj['a']
  # 1
  
  obj['a'] = 10
  obj['a']
  # 10
  ```

* key, val

  ```python
  dic = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5}
  obj = Series(dic)
  obj.values
  # array([1, 2, 3, 4, 5])
  
  obj.index
  # Index(['a', 'b', 'c', 'd', 'e'])
  ```

* size, shape, unique, count, mean, value_counts

  ```python
  s = pd.Series([1, 1, 2, 1, 2, 2, 2, 1, 1, 3, 3, 4, 5, 5, 7, np.NaN])
  s
  # 0     1.0
  # 1     1.0
  # 2     2.0
  # 3     1.0
  # 4     2.0
  # 5     2.0
  # 6     2.0
  # 7     1.0
  # 8     1.0
  # 9     3.0
  # 10    3.0
  # 11    4.0
  # 12    5.0
  # 13    5.0
  # 14    7.0
  # 15    NaN
  
  s.size	# 16
  s.shape	# (16, )
  s.unique()	# array([ 1.,  2.,  3.,  4.,  5.,  7., nan])
  s.count()	# 15	(NaN을 제외한 개수)
  s.mean()	# 2.666666..
  s.value_counts()	
  # 1.0    5
  # 2.0    4
  # 3.0    2
  # 5.0    2
  # 7.0    1
  # 4.0    1
  ```

* head, tail

  ```python
  df = 데이터프레임 형태 (column = series라고 불림)
  df.head()	# 처음 5줄 출력
  df.tail()	# 마지막 5줄 출력
  ```



###### 연산

* index 기준 연산

  ```python
  s1 = pd.Series([1, 2, 3, 4], ['a', 'b', 'c', 'd'])
  s2 = pd.Series([6, 3, 2, 1], ['d', 'c', 'b', 'a'])
  
  s1 + s2
  # a     2
  # b     4
  # c     6
  # d    10
  ```

* 스칼라와의 연산

  ```python
  s1 ** 2
  # a     1
  # b     4
  # c     9
  # d    16
  ```

  ```python
  s1 ** s2
  # a 1
  # b	4
  # c 27
  # d 4096
  ```

* index 맞지 않는 경우에는 NaN 값 생성됨

* 추가, 삭제

  ```python
  # 추가
  s['k'] = 300
  
  # 삭제
  S.drop('k', inplace=True)
  
  df.drop(1) # index_number로 drop
  df.drop([0, 3, 4])
  ```

  

###### dataframe

```python
df = pd.DataFrame(data, columns=['col1', 'col2','col3'])
df.col1 = df['col1']	# col1 선택
```

* shape

  ```python
  df.shape	# (891, 12)
  ```
  
* index, column

  ```python
  df.index	# RangeIndex(start=0, stop=891, step=1)
  df.columns	# Index(['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch', 'Ticket', 'Fare', 'Cabin', 'Embarked'], dtype='object')
  ```

* describe - 요약

  ```python
  df.describe()
  ```

* info

  ```python
  df.info()	# id, column, non-null count, dtype
  ```

* 생성

  ```python
  data = {'a' : 100, 'b' : 200, 'c' : 300}
  pd.DataFrame(data, index=['x', 'y', 'z'])
  
  	a	b	c
  x	100	200	300
  y	100	200	300
  z	100	200	300
  ```

  ```python
  a = pd.Series([100, 200, 300], ['a', 'b', 'd'])
  b = pd.Series([101, 201, 301], ['a', 'b', 'k'])
  c = pd.Series([110, 210, 310], ['a', 'b', 'c'])
  
  pd.DataFrame([a, b, c], index=[100, 101, 102])
  
  	a		b		d		k		c
  100	100.0	200.0	300.0	NaN		NaN
  101	101.0	201.0	NaN		301.0	NaN
  102	110.0	210.0	NaN		NaN		310.0
  ```

* column 선택

  ```python
  df['Survived']									# 하나
  df[['Survived', 'Name', 'Age', 'Embarked']]		# 여러개
  ```

* row 선택 - loc, iloc

  ```python
  df.loc[1]	# index location
  df.loc[[986, 100, 110, 990]]
  
  df['col2'].iloc[1:]		# index position
  ```

* column, row 동시 선택

  ```python
  df.loc[[986, 100, 110, 990], ['Survived', 'Name', 'Sex', 'Age']]
  df.iloc[[101, 100, 200, 102], [1, 4, 5]]
  ```

* column 삭제

  ```python
  del df['col1']
  ```

* filter

  ```python
  df.groupby('col1').filter(lambda x: len(x)>=3)
  ```

* sort_values - column 값 기준으로 정렬

  ```python
  df.sort_values(['col1', 'col2'], ascending=True)	# ascending : 오름차순
  ```

  



###### 상관관계

* 상관계수 연산 (-1 ~ 1)

```python
df.corr()
plt.matshow(df.corr())	# 시각화
```



###### NaN 처리

* NaN 값 확인

  ```python
  df.isna()
  df['Age'].isna()
  ```

* isnull

  ```python
  df.isnull()
  df.isnull().sum()	# null인 값의 합
  ```

* 삭제

  ```python
  df.dropna()
  df.dropna(subset=['Age', 'Cabin'])	# 특정 열에 NaN값이 있으면 행 삭제
  df.dropna(axis=1)	# 열 삭제
  ```

* 치환

  ```python
  1. 평균으로 대체
  df['Age'].fillna(df['Age'].mean())
  ```

  

###### group

* groupby

  ```python
  group_df = df.groupby('col1')['col3'].sum()	 # groupby(기준이 되는 컬럼)[적용받는 컬럼].적용받는 연산
  ```

* count, mean

  ```python
  group_df.count()
  group_df.mean()['Survived']				# 생존율
  group_df.groupby('Sex').mean()['Survived']	# 성별에 따른 생존율
  group_df.groupby(['Pclass', 'Sex']).mean()['Survived']	# 클래스와 성별에 따른 생존율
  ```

* index를 이용한 group by

  ```python
  df.set_index(['Pclass', 'Sex']).reset_index()	# 인덱스 초기화
  df.set_index('Age').groupby(level=0).mean()		# column 데이터를 index 레벨로 변경
  ```

* aggregate - 집계함수

  ```python
  df.set_index(['Pclass', 'Sex']).groupby(level=[0, 1]).aggregate([np.mean, np.sum, np.max])
  ```

* transform - group 후 원래의 index 유지한 상태로 통계함수 적용

  ```python
  df.groupby('Pclass').transform(np.mean)
  ```

  



###### pivot

* pivot

  ```python
  df.pivot('a','b')
  ```

* pivot_table

  * pivot 과의 차이점은 중복되는 모호한 값은 aggregation 함수를 사용해 값을 채울 수 있음

  ```python
  pd.pivot_table(df, index='요일', columns='지역', aggfunc=np.mean)
  ```





###### stack

* stack : 컬럼 레벨 -> 인덱스 레벨

  ```python
  new_df = df.set_index(['지역', '요일'])
  ```

* unstack : 인덱스 레벨 -> 컬럼 레벨

  ```python
  new_df.unstack(0)
  new_df.unstack(1)
  new_df.unstack(0).stack(0)
  ```

  ```python
  new_df.stack
  ```

  

###### 병합

* concat

  ```python
  # column명 같을 때
  df = pd.concat([df1, df2], ignore_index=True)
  df = pd.concat([df1, df2], axis=1)
  ```

  ```python
  # column명 다를 때 - 맞는 값끼리 반응 없으면 NaN
  df = pd.concat([df1, df2], axis=1)
  ```

* merge

  1. inner : 기본값
  2. left : left outer join
  3. right : right outer join
  4. outer : full outer join

  ```python
  pd.merge(customer, orders, on='customer_id', how='inner')
  pd.merge(customer, orders, on='customer_id', how='left')
  pd.merge(customer, orders, on='customer_id', how='right')
  pd.merge(customer, orders, on='customer_id', how='outer')
  ```

* index 기준으로 merge

  ```python
  cust1 = customer.set_index('customer_id')
  order1 = orders.set_index('customer_id')
  pd.merge(cust1, order1, left_index=True, right_index=True)
  
  pd.merge(df1, df2, on="id")		# id기준으로 merge
  pd.merge(df1, df2, left_on="df1_id", right_on="df2_id")
  ```

* join

  ```python
  cust1.join(order1, how='inner')
  ```

  