---
title: "Numpy - 02"
date: "2021-02-26T15:41:32.169Z"
path: "/Study/ml/5/"
category: "Study"
ci: "ML"
cat: "ML"
tags: ["ML", "Python", "Numpy"]
description: "ML - Numpy"
---



### Numpy

##### 사용

```python
import numpy as np
# 보통 np라는 별칭으로 호출
```

<br />

##### Random 서브모듈 사용

###### rand

* 0 ~ 1 사이의 랜덤한 ndarray 생성

```python
np.random.rand(1, 2)
# array([[0.41094072, 0.29208044]])
```



###### randn

* 정규분포의 값으로 랜덤한 ndarray 생성

```python
np.random.randn(5)
# array([ 0.81505902,  0.1570983 ,  0.97804151, -0.71402083,  0.0882037 ])
```



###### randint

* 특정 정수 사이에서 랜덤한 ndarray 생성

```python
np.random.randint(1, 100, size=(5,))
# array([97, 30, 18, 14, 55])
```



###### seed

* 랜덤 값을 동일하게 다시 생성하고자 할 때

```python
np.random.seed(23)	# 아무값이나 줘도 됨
np.random.randn(1, 2)
# array([[0.66698806, 0.02581308]])
```



###### choice

* 주어진 1차원 ndarray로부터 랜덤으로 샘플링
* 정수가 주어졌을 때, np.arange로 생각

```python
np.random.choice(100, size=(1, 4))
# array([[11, 84, 10, 80]])

x = np.array([1, 2, 3, 1.5, 2.6, 4.9])	# x에 들어있는 숫자들로 랜덤 생성
np.random.choice(x, size=(2, 2), replace=False)
# array([[2. , 1.5], [4.9, 3. ]])
```



###### 확률 분포에 따른 ndarray 생성

1. uniform

   ```python
   np.random.uniform(1.0, 3.0, size=(2, 3))
   # array([[1.59681371, 1.53761465, 2.77379625], [2.00651057, 2.14447524, 1.68483916]])
   ```

2. normal

   ```python
   np.random.normal(size=(1, 2))
   np.random.randn(2, 4)
   # array([[-2.02840457,  0.8137258 ,  0.33627294, -1.02056063], [ 0.09155003,  3.08886513,  0.48954752, -1.00011911]])
   ```

   



##### 연산 함수

* 주의 : shape이 동일해야함

###### add - 덧셈

```python
np.add(x, y) ==	x + y
```



###### substract - 뺄셈

```python
np.substract(x, y) == x - y
```



###### multiply - 곱셈

```python
np.multiply(x, y) == x * y
```



###### divide - 나눗셈

```python
np.divide(x, y) ==	x / y
```



##### 통계 함수

###### mean

```python
arr = np.arange(1, 13).reshape(3, 4)
arr.mean()
# 6.5
```



###### max, min

```python
np.max(y)
np.min(y)
```



###### argmax, argmin - array 내 최대, 최소 index 반환

```python
arr = np.arange(10)
np.argmax(arr), np.argmin(arr)
# (10, 0)
```



###### var, median, std

```python
np.var(y)	# 분산
np.median(y)	# 중앙값
np.std(y)	# 표준편차
```





##### 집계 함수

###### sum

```python
arr = np.arange(1, 11)
arr.sum(dtype=np.float)
# 55.0
np.sum(arr)
# 55

np.sum(arr, axis=)	# 축을 따라 합을 구할 수 있음
```



###### cumsum

```python
# 누적 합
arr = np.arange(1, 11)
np.cumsum(arr)
# array([ 1,  3,  6, 10, 15, 21, 28, 36, 45, 55], dtype=int32)
```



##### Shape이 다른 경우 연산

* 뒷 차원부터 비교하기 때문에, 주의 해야함.
  - (4, 3)인 shape는 (3, )과 (1, 3)은 가능한데, (4, )는 불가능함.



##### Boolean indexing

* 브로드캐스팅을 활용하여 ndarray로 부터 bool list 얻기

  - 예) 짝수인 경우만 반환

  ```python
  x = np.random.randint(1, 100, size=10)
  # [64 72 54 59 39 21 6 90 68 18]
  
  x[x % 2 == 0]
  # [64, 72, 54, 6, 90, 68, 18]
  
  x[x > 30]
  # [64, 72, 54, 59, 39, 90, 68]
  ```

  



##### 다중 조건

* & : and
* | : or

```python
x = np.random.randint(1, 100, size=10)
# [64 72 54 59 39 21 6 90 68 18]

x[(x % 2 == 0) & (x < 30)]
# array([ 6, 18])
```





##### linalg 서브 모듈 사용

###### inv

* 역행렬 구할 때 사용
* 모든 차원의 값 동일해야함

```python
x = np.random.rand(3, 3, 3)

# 두가지 방법
np.matmul(x, np.linalg.inv(x))
x @ np.linalg.inv(x)
```



###### solve

* Ax = B 선형대수식 솔루션
* x + y = 25 와 2x + 4y = 64 를 행렬식으로 표현해 풀기

```python
A = np.array([[1, 1], [2, 4]])
B = np.array([25, 64])

x = np.linalg.solve(A, B)
print(x)
# [18.  7.]

np.allclose(A@x, B)	# 둘이 비슷한지
# True
```









